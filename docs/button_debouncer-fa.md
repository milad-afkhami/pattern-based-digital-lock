> **[🇬🇧 English Version](button_debouncer.md)**

# ماژول حذف‌کننده نوسان دکمه

**فایل**: `src/button_debouncer.vhd`
**تعداد خطوط**: ۹۳
**هدف**: فیلتر کردن نوسان مکانیکی دکمه و ارائه پالس‌های خروجی تمیز و تک‌سیکلی

---

## فهرست مطالب

- [مقدمه](#مقدمه)
- [مشکل: نوسان دکمه](#مشکل-نوسان-دکمه)
- [واسط موجودیت](#واسط-موجودیت)
- [معماری](#معماری)
- [نحوه کار](#نحوه-کار)
- [مثال استفاده](#مثال-استفاده)
- [نمودار زمانی](#نمودار-زمانی)
- [پیکربندی](#پیکربندی)
- [تصمیمات طراحی](#تصمیمات-طراحی)

---

## مقدمه

ماژول `button_debouncer` دو مشکل بحرانی را با دکمه‌های مکانیکی حل می‌کند:

1. **فیلتر نوسان**: نادیده گرفتن گذارهای سریع روشن/خاموش ناشی از نوسان تماس مکانیکی
2. **تشخیص لبه**: تولید دقیقاً یک پالس خروجی به ازای هر فشردن دکمه، صرف نظر از مدت نگه‌داری دکمه

<details>
<summary>چرا به حذف نوسان نیاز داریم؟</summary>

وقتی یک دکمه فیزیکی را فشار می‌دهید، تماس‌های فلزی اتصال تمیزی برقرار نمی‌کنند. آن‌ها «نوسان» می‌کنند - به سرعت برای چند میلی‌ثانیه وصل و قطع می‌شوند قبل از اینکه تثبیت شوند. بدون حذف نوسان، یک فشردن دکمه ممکن است به صورت ۱۰ تا ۵۰ فشردن سریع ثبت شود!

</details>

---

## مشکل: نوسان دکمه

### سیگنال خام دکمه (نوسانی)

```
رویداد فشردن دکمه:

فعل          ____________________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\____
فیزیکی           ↑                                                ↑
              فشردن                                            رها کردن

سیگنال       ____/‾\_/‾‾\_/‾‾‾‾\__/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\_/‾‾\_/‾\_____
خام               ↑                                    ↑
               نوسان                                نوسان
             (۵-۲۰ میلی‌ثانیه)                    (۵-۲۰ میلی‌ثانیه)
```

### آنچه ماشین حالت بدون حذف نوسان می‌بیند

بدون حذف نوسان، ماشین حالت چندین فشردن دکمه می‌بیند:
- کاربر یک بار A را فشار می‌دهد ← ماشین حالت ۵-۱۰ بار A فشرده شده می‌بیند
- کاربر A، B، C، A را فشار می‌دهد ← ماشین حالت A، A، A، B، B، C، C، A، A، A می‌بیند
- نتیجه: رفتار غیرقابل پیش‌بینی، وارد کردن توالی باز کردن غیرممکن است

### راه‌حل: خروجی حذف نوسان شده و تشخیص لبه

![سیگنال نوسانی در مقابل حذف نوسان شده](../presentation/assets/Bounce-vs-Debounced-Signal.png)

```
حذف نوسان  ________________________________/‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾‾\______
(پایدار)

خروجی      ________________________________/‾\__________________________
(پالس)                                      ↑
                                   پالس تک‌سیکلی
```

---

## واسط موجودیت

```vhdl
entity button_debouncer is
    Generic (
        DEBOUNCE_TIME : integer := 10
    );
    Port (
        clk        : in  std_logic;
        reset      : in  std_logic;
        button_in  : in  std_logic;
        button_out : out std_logic
    );
end button_debouncer;
```

### پارامترهای عمومی

| پارامتر | نوع | مقدار پیش‌فرض | توضیحات |
|---------|-----|---------------|---------|
| `DEBOUNCE_TIME` | integer | ۱۰ | سیکل‌های کلاک برای پایداری |

<details>
<summary>نحوه محاسبه DEBOUNCE_TIME</summary>

فرمول: `DEBOUNCE_TIME = دوره_حذف_نوسان × فرکانس_کلاک`

مثال‌ها:
- حذف نوسان ۱۰ میلی‌ثانیه در ۱۰۰ مگاهرتز: ۰.۰۱۰ × ۱۰۰٬۰۰۰٬۰۰۰ = ۱٬۰۰۰٬۰۰۰
- حذف نوسان ۲۰ میلی‌ثانیه در ۵۰ مگاهرتز: ۰.۰۲۰ × ۵۰٬۰۰۰٬۰۰۰ = ۱٬۰۰۰٬۰۰۰

برای شبیه‌سازی، از مقادیر کوچک (۱۰-۱۰۰) برای سریع نگه داشتن شبیه‌سازی استفاده کنید.

مقادیر معمول دنیای واقعی: ۱۰-۲۰ میلی‌ثانیه (۱-۲ میلیون سیکل در ۱۰۰ مگاهرتز)

</details>

### پورت‌ها

| پورت | جهت | نوع | توضیحات |
|------|-----|-----|---------|
| `clk` | ورودی | std_logic | کلاک سیستم |
| `reset` | ورودی | std_logic | بازنشانی ناهمگام، فعال-بالا |
| `button_in` | ورودی | std_logic | ورودی خام دکمه (ممکن است نوسان داشته باشد) |
| `button_out` | خروجی | std_logic | خروجی پالس تمیز و تک‌سیکلی |

---

## معماری

### سیگنال‌های داخلی

```vhdl
signal counter       : integer range 0 to DEBOUNCE_TIME := 0;
signal button_sync   : std_logic_vector(1 downto 0) := "00";
signal button_stable : std_logic := '0';
signal button_prev   : std_logic := '0';
```

| سیگنال | نوع | توضیحات |
|--------|-----|---------|
| `counter` | integer | شمارنده پایداری (در حالی که ورودی پایدار است شمارش می‌کند) |
| `button_sync` | std_logic_vector(1:0) | همگام‌ساز ۲ مرحله‌ای برای شبه‌پایداری |
| `button_stable` | std_logic | وضعیت حذف نوسان شده دکمه |
| `button_prev` | std_logic | وضعیت پایدار قبلی (برای تشخیص لبه) |

<details>
<summary>شبه‌پایداری چیست؟</summary>

**شبه‌پایداری** زمانی رخ می‌دهد که یک سیگنال دقیقاً همزمان با رسیدن لبه کلاک تغییر کند. فلیپ‌فلاپ نمی‌تواند بین ۰ و ۱ تصمیم بگیرد و خروجی ناپایدار تولید می‌کند.

یک **همگام‌ساز** (دو فلیپ‌فلاپ به صورت سری) به سیگنال دو سیکل کلاک می‌دهد تا قبل از استفاده پایدار شود و عملاً مشکلات شبه‌پایداری را حذف می‌کند.

```
button_in → [FF1] → [FF2] → button_sync(0)
             ↑        ↑
          ممکن است   پایدار
         ناپایدار باشد
```

</details>

---

## نحوه کار

### جریان پردازش

![جریان پردازش](../presentation/assets/Processing-Flow.png)

### مرحله ۱: همگام‌سازی

```vhdl
-- همگام‌ساز دو مرحله‌ای برای حفاظت از شبه‌پایداری
button_sync <= button_sync(0) & button_in;
```

ورودی خام دکمه از دو فلیپ‌فلاپ عبور می‌کند تا از تأثیر شبه‌پایداری بر منطق پایین‌دست جلوگیری شود.

### مرحله ۲: شمارش حذف نوسان

```vhdl
-- شمارش زمان پایداری
if button_sync(1) /= button_stable then
    -- ورودی تغییر کرده، شروع شمارش
    if counter >= DEBOUNCE_TIME then
        button_stable <= button_sync(1);  -- پذیرش مقدار جدید
        counter <= 0;
    else
        counter <= counter + 1;  -- ادامه شمارش
    end if;
else
    counter <= 0;  -- ورودی با پایدار مطابقت دارد، بازنشانی شمارنده
end if;
```

شمارنده فقط زمانی افزایش می‌یابد که ورودی با خروجی پایدار متفاوت باشد. اگر ورودی برای `DEBOUNCE_TIME` سیکل متفاوت بماند، به عنوان مقدار پایدار جدید پذیرفته می‌شود.

### مرحله ۳: تشخیص لبه

```vhdl
-- به خاطر سپردن وضعیت پایدار قبلی
button_prev <= button_stable;

-- تولید پالس روی لبه بالارونده
if button_stable = '1' and button_prev = '0' then
    button_out <= '1';  -- لبه بالارونده تشخیص داده شد!
else
    button_out <= '0';
end if;
```

با مقایسه وضعیت پایدار فعلی با وضعیت پایدار قبلی، لحظه دقیق گذار دکمه از فشرده نشده به فشرده شده را تشخیص می‌دهیم.

<details>
<summary>چرا تشخیص لبه بالارونده؟</summary>

بدون تشخیص لبه، نگه داشتن یک دکمه به طور مداوم '1' خروجی می‌دهد. ماشین حالت همان دکمه را در هر سیکل کلاک فشرده شده می‌بیند و خیلی سریع بین حالات پیش می‌رود.

با تشخیص لبه:
- فشردن و نگه داشتن دکمه A ← یک پالس تولید می‌شود
- رها کردن دکمه A ← پالسی تولید نمی‌شود
- فشردن مجدد دکمه A ← یک پالس تولید می‌شود

این تضمین می‌کند که هر فشردن فیزیکی = دقیقاً یک گذار ماشین حالت.

</details>

---

## مثال استفاده

### نمونه‌سازی پایه

```vhdl
debounce_btn_a: entity work.button_debouncer
    generic map (
        DEBOUNCE_TIME => 1000000  -- ~۱۰ میلی‌ثانیه در ۱۰۰ مگاهرتز
    )
    port map (
        clk        => system_clock,
        reset      => system_reset,
        button_in  => raw_button_a,  -- از دکمه فیزیکی
        button_out => clean_button_a  -- به ماشین حالت
    );
```

### چندین دکمه

```vhdl
-- ایجاد ۴ دکمه حذف نوسان شده
gen_debouncers: for i in 0 to 3 generate
    debouncer: entity work.button_debouncer
        generic map (DEBOUNCE_TIME => DEBOUNCE_CYCLES)
        port map (
            clk        => clk,
            reset      => reset,
            button_in  => raw_buttons(i),
            button_out => clean_buttons(i)
        );
end generate;
```

---

## نمودار زمانی

### فشردن عادی دکمه

```
clk          ─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─┐ ┌─
              └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘ └─┘

button_in    ──────────────┐                       ┌───────────────
(خام)                      └───────────────────────┘

counter           0   1   2   3   4   5   0   0   1   2   3   4   5

button_stable ────────────────────────────┐       ┌────────────────
(حذف نوسان شده)                           └───────┘

button_out   ─────────────────────────────┐ ┌─────────────────────
(پالس)                                    └─┘
                                          ↑
                                   پالس تک‌سیکلی
                                   روی لبه بالارونده
```

### فشردن نوسانی دکمه (فیلتر شده)

```
button_in    ──────┐ ┌─┐ ┌─┐ ┌──────────────────────────────────
(نوسانی)           └─┘ └─┘ └─┘
                   ↑       ↑
                نوسان‌ها  تثبیت

counter           0 1 0 1 0 1 2 3 4 5
                  ↑   ↑
               با هر نوسان بازنشانی می‌شود

button_stable ────────────────────────────┐
                                          └─ (پس از DEBOUNCE_TIME تغییر می‌کند)

button_out   ─────────────────────────────┐ ┌──
                                          └─┘
```

### فشردن کوتاه (فیلتر شده)

```
button_in    ──────────┐   ┌───────────────────────────────────
(خیلی کوتاه)           └───┘
                       ← ۳ →  (کمتر از DEBOUNCE_TIME=5)

counter           0   1   2   3   0   0   0
                                  ↑
                           قبل از رسیدن به ۵ بازنشانی می‌شود

button_stable ─────────────────────────────────────────────────
                              (هرگز تغییر نمی‌کند)

button_out   ──────────────────────────────────────────────────
                              (پالسی تولید نمی‌شود)
```

---

## پیکربندی

### تنظیمات شبیه‌سازی

```vhdl
-- شبیه‌سازی سریع (واقع‌گرایانه نیست اما سریع)
DEBOUNCE_TIME => 5
```

### تنظیمات سخت‌افزار واقعی

| فرکانس کلاک | دوره حذف نوسان | DEBOUNCE_TIME |
|-------------|----------------|---------------|
| ۵۰ مگاهرتز | ۱۰ میلی‌ثانیه | ۵۰۰٬۰۰۰ |
| ۵۰ مگاهرتز | ۲۰ میلی‌ثانیه | ۱٬۰۰۰٬۰۰۰ |
| ۱۰۰ مگاهرتز | ۱۰ میلی‌ثانیه | ۱٬۰۰۰٬۰۰۰ |
| ۱۰۰ مگاهرتز | ۲۰ میلی‌ثانیه | ۲٬۰۰۰٬۰۰۰ |

<details>
<summary>نحوه انتخاب دوره حذف نوسان</summary>

دکمه‌های مکانیکی معمولی برای ۵-۲۰ میلی‌ثانیه نوسان دارند. توصیه‌ها:

- **۱۰ میلی‌ثانیه**: خوب برای دکمه‌های با کیفیت بالا، پاسخ سریع‌تر
- **۲۰ میلی‌ثانیه**: امن برای اکثر دکمه‌ها، پاسخ کمی کندتر
- **۵۰ میلی‌ثانیه**: بسیار محافظه‌کارانه، تأخیر قابل توجه

با ۲۰ میلی‌ثانیه شروع کنید و بر اساس دکمه‌های خاص خود تنظیم کنید. اگر گاهی فشردن‌های مضاعف می‌بینید، زمان حذف نوسان را افزایش دهید.

</details>

---

## تصمیمات طراحی

### چرا رویکرد مبتنی بر شمارنده؟

حذف نوسان مبتنی بر شمارنده:
- **ساده**: درک و پیاده‌سازی آسان
- **قابل پیش‌بینی**: زمان حذف نوسان ثابت، رفتار قطعی
- **کارآمد از نظر منابع**: فقط یک شمارنده به ازای هر دکمه
- **قابل تنظیم**: تغییر زمان‌بندی با یک پارامتر عمومی واحد

رویکردهای جایگزین (ثبات‌های شیفت، فیلترهای RC آنالوگ) پیچیده‌تر هستند بدون مزایای قابل توجه برای این کاربرد.

### چرا همگام‌سازی ۲ مرحله‌ای؟

یک همگام‌ساز ۲ مرحله‌ای احتمال شبه‌پایداری را به سطوح ناچیز کاهش می‌دهد:
- تک فلیپ‌فلاپ: ~۱۰٪ احتمال انتشار خروجی شبه‌پایدار
- دو فلیپ‌فلاپ: ~۰.۰۱٪ احتمال
- برای کاربردهای بحرانی، می‌توان از ۳ مرحله استفاده کرد

### چرا تشخیص لبه داخل حذف‌کننده نوسان؟

یکپارچه‌سازی تشخیص لبه در حذف‌کننده نوسان:
- تعداد اجزای خارجی را کاهش می‌دهد
- تضمین می‌کند که خروجی همیشه یک پالس منفرد تمیز است
- ماشین حالت را ساده می‌کند (نیاز به منطق تشخیص لبه نیست)
- با انتظارات ماشین حالت مطابقت دارد (یک پالس به ازای هر فشردن)

### چرا از ماژول‌های جداگانه حذف نوسان و تشخیص لبه استفاده نشد؟

در حالی که طراحی ماژولار خوب است، ترکیب آن‌ها:
- مشکلات احتمالی زمان‌بندی بین ماژول‌ها را کاهش می‌دهد
- عملیات اتمی را تضمین می‌کند (حذف نوسان + تشخیص لبه با هم اتفاق می‌افتند)
- طراحی سطح بالا را ساده می‌کند
- روش متداول صنعتی برای واسط‌های دکمه است
